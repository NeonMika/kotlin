/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.build.asm

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import org.gradle.api.DefaultTask
import org.gradle.api.GradleException
import org.gradle.api.file.ArchiveOperations
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.util.PatternSet
import org.gradle.kotlin.dsl.named
import org.gradle.kotlin.dsl.register
import org.gradle.kotlin.dsl.support.serviceOf
import org.jetbrains.org.objectweb.asm.ClassReader
import org.jetbrains.org.objectweb.asm.ClassWriter
import java.io.File
import java.util.*
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

/**
 * Allows configuring ad-hoc deprecation of classes included in fat jar generated by a [ShadowJar] task.
 * Context: https://youtrack.jetbrains.com/issue/KT-70251
 */
abstract class AsmDeprecationExtension {
    fun ShadowJar.deprecateClassesByPattern(pattern: String, deprecationMessage: String, exclusions: List<String> = emptyList()) {
        val patternSet = PatternSet()
        patternSet.include(pattern.replace('.', '/'))
        patternSet.exclude(exclusions.map { it.replace('.', '/') })
        val spec = patternSet.asSpec
        val archiveOperations = project.serviceOf<ArchiveOperations>()
        val deprecationList = project.provider {
            val outputFile = archiveFile.get().asFile
            outputFile.parentFile.resolve("${outputFile.name}$PATH_SUFFIX")
        }
        inputs.property("pattern", pattern)
        inputs.property("deprecationMessage", deprecationMessage)
        for ((index, exclusion) in exclusions.withIndex()) {
            inputs.property("exclusion$index", exclusion)
        }
        outputs.file(deprecationList)
        doLast {
            val intermediateZipFilePath = temporaryDir.resolve("${UUID.randomUUID()}.${archiveExtension.get()}")
            ZipOutputStream(intermediateZipFilePath.outputStream()).use { intermediateZipFile ->
                val deprecatedPackages = sortedSetOf<String>()
                archiveOperations.zipTree(archiveFile.get().asFile).visit {
                    if (name.endsWith(".class") && spec.isSatisfiedBy(this)) {
                        val classReader = ClassReader(file.inputStream())
                        val classWriter = ClassWriter(classReader, ClassWriter.COMPUTE_FRAMES)
                        val classVisitor = DeprecatingClassTransformer(classWriter, deprecationMessage) { className ->
                            logger.info("Deprecating class $className")
                            deprecatedPackages.add(className.substringBeforeLast("."))
                        }
                        classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES)
                        val newBytes = classWriter.toByteArray()
                        val newEntry = ZipEntry(path)
                        intermediateZipFile.putNextEntry(newEntry)
                        intermediateZipFile.write(newBytes)
                        intermediateZipFile.closeEntry()
                    } else {
                        val newEntry = ZipEntry(if (isDirectory) "$path/" else path)
                        intermediateZipFile.putNextEntry(newEntry)
                        if (!isDirectory) {
                            file.inputStream().use {
                                it.copyTo(intermediateZipFile)
                            }
                        }
                        intermediateZipFile.closeEntry()
                    }
                }
                deprecationList.get().outputStream().bufferedWriter().use { deprecationListWriter ->
                    deprecationListWriter.appendLine("The following packages (non-transitively) are (non-transitively) deprecated by the `asm-deprecating-transformer` plugin:")
                    deprecatedPackages.forEach { packageName ->
                        deprecationListWriter.appendLine("package $packageName")
                    }
                }
            }
            intermediateZipFilePath.renameTo(archiveFile.get().asFile)
        }
    }

    fun TaskContainer.registerDumpDeprecationsTask(shadowJarTaskName: String, suffix: String) =
        register<Copy>("dumpDeprecationsFor${suffix}") {
            val shadowJarTask = named<ShadowJar>(shadowJarTaskName)
            val actualDeprecations =
                shadowJarTask.map { it.archiveFile.get().asFile.parentFile.resolve("${it.archiveFile.get().asFile.name}$PATH_SUFFIX") }
            from(actualDeprecations)
            into(project.layout.projectDirectory.dir(BUILD_DIRECTORY))
            rename {
                "$suffix$PATH_SUFFIX"
            }
        }

    fun TaskContainer.registerCheckDeprecationsTask(
        shadowJarTaskName: String,
        suffix: String,
        expectedFileDoesNotExistMessage: String,
        checkFailureMessage: String,
    ) =
        register<DefaultTask>("checkDeprecationsFor${suffix}") {
            val shadowJarTask = named<ShadowJar>(shadowJarTaskName)
            val actualDeprecations =
                shadowJarTask.map { it.archiveFile.get().asFile.parentFile.resolve("${it.archiveFile.get().asFile.name}$PATH_SUFFIX") }
            val expectedDeprecations = project.layout.projectDirectory.file("$BUILD_DIRECTORY/$suffix$PATH_SUFFIX")
            inputs.file(actualDeprecations)
            // `files` to check it manually and give an actionable failure message.
            // otherwise Gradle will complain that the input file does not exist
            inputs.files(expectedDeprecations)
            doFirst {
                val expectedFile = expectedDeprecations.asFile
                if (!expectedFile.exists()) {
                    throw GradleException(expectedFileDoesNotExistMessage)
                }
                val actualFile = actualDeprecations.get()
                if (!expectedFile.equalTo(actualFile)) {
                    throw GradleException(checkFailureMessage)
                }
            }
        }

    companion object {
        private const val PATH_SUFFIX = ".deprecations"
        private const val BUILD_DIRECTORY = "asm-deprecation"

        private fun File.equalTo(other: File): Boolean {
            if (this.length() != other.length()) {
                return false
            }
            this.inputStream().use { fis1 ->
                other.inputStream().use { fis2 ->
                    val thisBuffer = ByteArray(1024)
                    val otherBuffer = ByteArray(1024)

                    var thisBytesRead: Int
                    var otherBytesRead: Int

                    do {
                        thisBytesRead = fis1.read(thisBuffer)
                        otherBytesRead = fis2.read(otherBuffer)

                        if (thisBytesRead != otherBytesRead || !thisBuffer.contentEquals(otherBuffer)) {
                            return false
                        }
                    } while (thisBytesRead > 0)
                }
            }
            return true
        }
    }
}